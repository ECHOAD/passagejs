/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Timestamp, Uint64, Addr, Uint128, AuctionStatus, AuctionResponse, Auction, AuctionBid, Coin, AuctionsResponse, Decimal, ConfigResponse, Config, ExecuteMsg, InstantiateMsg, QueryMsg, QueryOptionsForTokenTimestampOffset, TokenTimestampOffset, QueryOptionsForTokenPriceOffset, TokenPriceOffset } from "./AuctionEnglish.types";
export interface AuctionEnglishReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  auction: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<AuctionResponse>;
  auctionsByStartTime: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }) => Promise<AuctionsByStartTimeResponse>;
  auctionsByEndTime: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }) => Promise<AuctionsByEndTimeResponse>;
  auctionsByHighestBidPrice: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenPriceOffset;
  }) => Promise<AuctionsByHighestBidPriceResponse>;
  auctionsBySellerEndTime: ({
    queryOptions,
    seller
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
    seller: string;
  }) => Promise<AuctionsBySellerEndTimeResponse>;
  auctionsByBidderEndTime: ({
    bidder,
    queryOptions
  }: {
    bidder: string;
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }) => Promise<AuctionsByBidderEndTimeResponse>;
}
export class AuctionEnglishQueryClient implements AuctionEnglishReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.auction = this.auction.bind(this);
    this.auctionsByStartTime = this.auctionsByStartTime.bind(this);
    this.auctionsByEndTime = this.auctionsByEndTime.bind(this);
    this.auctionsByHighestBidPrice = this.auctionsByHighestBidPrice.bind(this);
    this.auctionsBySellerEndTime = this.auctionsBySellerEndTime.bind(this);
    this.auctionsByBidderEndTime = this.auctionsByBidderEndTime.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  auction = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<AuctionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auction: {
        token_id: tokenId
      }
    });
  };
  auctionsByStartTime = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }): Promise<AuctionsByStartTimeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auctions_by_start_time: {
        query_options: queryOptions
      }
    });
  };
  auctionsByEndTime = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }): Promise<AuctionsByEndTimeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auctions_by_end_time: {
        query_options: queryOptions
      }
    });
  };
  auctionsByHighestBidPrice = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenPriceOffset;
  }): Promise<AuctionsByHighestBidPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auctions_by_highest_bid_price: {
        query_options: queryOptions
      }
    });
  };
  auctionsBySellerEndTime = async ({
    queryOptions,
    seller
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
    seller: string;
  }): Promise<AuctionsBySellerEndTimeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auctions_by_seller_end_time: {
        query_options: queryOptions,
        seller
      }
    });
  };
  auctionsByBidderEndTime = async ({
    bidder,
    queryOptions
  }: {
    bidder: string;
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }): Promise<AuctionsByBidderEndTimeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      auctions_by_bidder_end_time: {
        bidder,
        query_options: queryOptions
      }
    });
  };
}
export interface AuctionEnglishInterface extends AuctionEnglishReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    bufferDuration,
    closedDuration,
    collectorAddress,
    maxDuration,
    minBidIncrement,
    minDuration,
    minPrice,
    operators,
    tradingFeeBps
  }: {
    bufferDuration?: number;
    closedDuration?: number;
    collectorAddress?: string;
    maxDuration?: number;
    minBidIncrement?: Uint128;
    minDuration?: number;
    minPrice?: Uint128;
    operators?: string[];
    tradingFeeBps?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAuction: ({
    endTime,
    fundsRecipient,
    reservePrice,
    startTime,
    startingPrice,
    tokenId
  }: {
    endTime: Timestamp;
    fundsRecipient?: string;
    reservePrice?: Coin;
    startTime: Timestamp;
    startingPrice: Coin;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAuctionBid: ({
    price,
    tokenId
  }: {
    price: Coin;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  closeAuction: ({
    acceptHighestBid,
    tokenId
  }: {
    acceptHighestBid: boolean;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  finalizeAuction: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  voidAuction: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class AuctionEnglishClient extends AuctionEnglishQueryClient implements AuctionEnglishInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.setAuction = this.setAuction.bind(this);
    this.setAuctionBid = this.setAuctionBid.bind(this);
    this.closeAuction = this.closeAuction.bind(this);
    this.finalizeAuction = this.finalizeAuction.bind(this);
    this.voidAuction = this.voidAuction.bind(this);
  }

  updateConfig = async ({
    bufferDuration,
    closedDuration,
    collectorAddress,
    maxDuration,
    minBidIncrement,
    minDuration,
    minPrice,
    operators,
    tradingFeeBps
  }: {
    bufferDuration?: number;
    closedDuration?: number;
    collectorAddress?: string;
    maxDuration?: number;
    minBidIncrement?: Uint128;
    minDuration?: number;
    minPrice?: Uint128;
    operators?: string[];
    tradingFeeBps?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        buffer_duration: bufferDuration,
        closed_duration: closedDuration,
        collector_address: collectorAddress,
        max_duration: maxDuration,
        min_bid_increment: minBidIncrement,
        min_duration: minDuration,
        min_price: minPrice,
        operators,
        trading_fee_bps: tradingFeeBps
      }
    }, fee, memo, _funds);
  };
  setAuction = async ({
    endTime,
    fundsRecipient,
    reservePrice,
    startTime,
    startingPrice,
    tokenId
  }: {
    endTime: Timestamp;
    fundsRecipient?: string;
    reservePrice?: Coin;
    startTime: Timestamp;
    startingPrice: Coin;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_auction: {
        end_time: endTime,
        funds_recipient: fundsRecipient,
        reserve_price: reservePrice,
        start_time: startTime,
        starting_price: startingPrice,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setAuctionBid = async ({
    price,
    tokenId
  }: {
    price: Coin;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_auction_bid: {
        price,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  closeAuction = async ({
    acceptHighestBid,
    tokenId
  }: {
    acceptHighestBid: boolean;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close_auction: {
        accept_highest_bid: acceptHighestBid,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  finalizeAuction = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      finalize_auction: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  voidAuction = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      void_auction: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}