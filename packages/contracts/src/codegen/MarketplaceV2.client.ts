/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AskCountResponse, Timestamp, Uint64, Addr, Uint128, AskResponse, Ask, Coin, AsksResponse, BidResponse, Bid, BidsResponse, CollectionBidExpiryOffset, CollectionBidPriceOffset, CollectionBidResponse, CollectionBid, CollectionBidsResponse, Decimal, ConfigResponse, Config, ExpiryRange, ExecuteMsg, InstantiateMsg, MarketplaceContract, QueryMsg, QueryOptionsForTokenTimestampOffset, TokenTimestampOffset, QueryOptionsForTokenPriceOffset, TokenPriceOffset, QueryOptionsForBidExpiryOffset, BidExpiryOffset, QueryOptionsForBidTokenPriceOffset, BidTokenPriceOffset, QueryOptionsForCollectionBidPriceOffset, QueryOptionsForCollectionBidExpiryOffset } from "./MarketplaceV2.types";
export interface MarketplaceV2ReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  ask: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<AskResponse>;
  asksSortedByExpiry: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }) => Promise<AsksSortedByExpiryResponse>;
  asksSortedByPrice: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenPriceOffset;
  }) => Promise<AsksSortedByPriceResponse>;
  asksBySellerExpiry: ({
    queryOptions,
    seller
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
    seller: string;
  }) => Promise<AsksBySellerExpiryResponse>;
  askCount: () => Promise<AskCountResponse>;
  bid: ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }) => Promise<BidResponse>;
  bidsSortedByExpiry: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForBidExpiryOffset;
  }) => Promise<BidsSortedByExpiryResponse>;
  bidsByTokenPrice: ({
    queryOptions,
    tokenId
  }: {
    queryOptions: QueryOptionsForBidTokenPriceOffset;
    tokenId: string;
  }) => Promise<BidsByTokenPriceResponse>;
  bidsByBidderExpiry: ({
    bidder,
    queryOptions
  }: {
    bidder: string;
    queryOptions: QueryOptionsForBidExpiryOffset;
  }) => Promise<BidsByBidderExpiryResponse>;
  collectionBid: ({
    bidder
  }: {
    bidder: string;
  }) => Promise<CollectionBidResponse>;
  collectionBidsByPrice: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForCollectionBidPriceOffset;
  }) => Promise<CollectionBidsByPriceResponse>;
  collectionBidsByExpiry: ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForCollectionBidExpiryOffset;
  }) => Promise<CollectionBidsByExpiryResponse>;
}
export class MarketplaceV2QueryClient implements MarketplaceV2ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.ask = this.ask.bind(this);
    this.asksSortedByExpiry = this.asksSortedByExpiry.bind(this);
    this.asksSortedByPrice = this.asksSortedByPrice.bind(this);
    this.asksBySellerExpiry = this.asksBySellerExpiry.bind(this);
    this.askCount = this.askCount.bind(this);
    this.bid = this.bid.bind(this);
    this.bidsSortedByExpiry = this.bidsSortedByExpiry.bind(this);
    this.bidsByTokenPrice = this.bidsByTokenPrice.bind(this);
    this.bidsByBidderExpiry = this.bidsByBidderExpiry.bind(this);
    this.collectionBid = this.collectionBid.bind(this);
    this.collectionBidsByPrice = this.collectionBidsByPrice.bind(this);
    this.collectionBidsByExpiry = this.collectionBidsByExpiry.bind(this);
  }
  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  ask = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<AskResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ask: {
        token_id: tokenId
      }
    });
  };
  asksSortedByExpiry = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  }): Promise<AsksSortedByExpiryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_sorted_by_expiry: {
        query_options: queryOptions
      }
    });
  };
  asksSortedByPrice = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForTokenPriceOffset;
  }): Promise<AsksSortedByPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_sorted_by_price: {
        query_options: queryOptions
      }
    });
  };
  asksBySellerExpiry = async ({
    queryOptions,
    seller
  }: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
    seller: string;
  }): Promise<AsksBySellerExpiryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asks_by_seller_expiry: {
        query_options: queryOptions,
        seller
      }
    });
  };
  askCount = async (): Promise<AskCountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ask_count: {}
    });
  };
  bid = async ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }): Promise<BidResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bid: {
        bidder,
        token_id: tokenId
      }
    });
  };
  bidsSortedByExpiry = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForBidExpiryOffset;
  }): Promise<BidsSortedByExpiryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bids_sorted_by_expiry: {
        query_options: queryOptions
      }
    });
  };
  bidsByTokenPrice = async ({
    queryOptions,
    tokenId
  }: {
    queryOptions: QueryOptionsForBidTokenPriceOffset;
    tokenId: string;
  }): Promise<BidsByTokenPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bids_by_token_price: {
        query_options: queryOptions,
        token_id: tokenId
      }
    });
  };
  bidsByBidderExpiry = async ({
    bidder,
    queryOptions
  }: {
    bidder: string;
    queryOptions: QueryOptionsForBidExpiryOffset;
  }): Promise<BidsByBidderExpiryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      bids_by_bidder_expiry: {
        bidder,
        query_options: queryOptions
      }
    });
  };
  collectionBid = async ({
    bidder
  }: {
    bidder: string;
  }): Promise<CollectionBidResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_bid: {
        bidder
      }
    });
  };
  collectionBidsByPrice = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForCollectionBidPriceOffset;
  }): Promise<CollectionBidsByPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_bids_by_price: {
        query_options: queryOptions
      }
    });
  };
  collectionBidsByExpiry = async ({
    queryOptions
  }: {
    queryOptions: QueryOptionsForCollectionBidExpiryOffset;
  }): Promise<CollectionBidsByExpiryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_bids_by_expiry: {
        query_options: queryOptions
      }
    });
  };
}
export interface MarketplaceV2Interface extends MarketplaceV2ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    askExpiry,
    bidExpiry,
    minPrice,
    operators,
    tradingFeeBps
  }: {
    askExpiry?: ExpiryRange;
    bidExpiry?: ExpiryRange;
    minPrice?: Uint128;
    operators?: string[];
    tradingFeeBps?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setAsk: ({
    expiresAt,
    fundsRecipient,
    price,
    reserveFor,
    tokenId
  }: {
    expiresAt: Timestamp;
    fundsRecipient?: string;
    price: Coin;
    reserveFor?: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAsk: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setBid: ({
    expiresAt,
    price,
    tokenId
  }: {
    expiresAt: Timestamp;
    price: Coin;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeBid: ({
    tokenId
  }: {
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptBid: ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setCollectionBid: ({
    expiresAt,
    price,
    units
  }: {
    expiresAt: Timestamp;
    price: Coin;
    units: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCollectionBid: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptCollectionBid: ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MarketplaceV2Client extends MarketplaceV2QueryClient implements MarketplaceV2Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.setAsk = this.setAsk.bind(this);
    this.removeAsk = this.removeAsk.bind(this);
    this.setBid = this.setBid.bind(this);
    this.removeBid = this.removeBid.bind(this);
    this.acceptBid = this.acceptBid.bind(this);
    this.setCollectionBid = this.setCollectionBid.bind(this);
    this.removeCollectionBid = this.removeCollectionBid.bind(this);
    this.acceptCollectionBid = this.acceptCollectionBid.bind(this);
  }
  updateConfig = async ({
    askExpiry,
    bidExpiry,
    minPrice,
    operators,
    tradingFeeBps
  }: {
    askExpiry?: ExpiryRange;
    bidExpiry?: ExpiryRange;
    minPrice?: Uint128;
    operators?: string[];
    tradingFeeBps?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        ask_expiry: askExpiry,
        bid_expiry: bidExpiry,
        min_price: minPrice,
        operators,
        trading_fee_bps: tradingFeeBps
      }
    }, fee, memo, _funds);
  };
  setAsk = async ({
    expiresAt,
    fundsRecipient,
    price,
    reserveFor,
    tokenId
  }: {
    expiresAt: Timestamp;
    fundsRecipient?: string;
    price: Coin;
    reserveFor?: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_ask: {
        expires_at: expiresAt,
        funds_recipient: fundsRecipient,
        price,
        reserve_for: reserveFor,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeAsk = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_ask: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setBid = async ({
    expiresAt,
    price,
    tokenId
  }: {
    expiresAt: Timestamp;
    price: Coin;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_bid: {
        expires_at: expiresAt,
        price,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  removeBid = async ({
    tokenId
  }: {
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_bid: {
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  acceptBid = async ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_bid: {
        bidder,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  setCollectionBid = async ({
    expiresAt,
    price,
    units
  }: {
    expiresAt: Timestamp;
    price: Coin;
    units: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_collection_bid: {
        expires_at: expiresAt,
        price,
        units
      }
    }, fee, memo, _funds);
  };
  removeCollectionBid = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_collection_bid: {}
    }, fee, memo, _funds);
  };
  acceptCollectionBid = async ({
    bidder,
    tokenId
  }: {
    bidder: string;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_collection_bid: {
        bidder,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
}