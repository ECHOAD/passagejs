/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Timestamp, Uint64, Addr, Uint128, AuctionStatus, AuctionResponse, Auction, AuctionBid, Coin, AuctionsResponse, Decimal, ConfigResponse, Config, ExecuteMsg, InstantiateMsg, QueryMsg, QueryOptionsForTokenTimestampOffset, TokenTimestampOffset, QueryOptionsForTokenPriceOffset, TokenPriceOffset } from "./AuctionEnglish.types";
import { AuctionEnglishQueryClient, AuctionEnglishClient } from "./AuctionEnglish.client";
export interface AuctionEnglishReactQuery<TResponse, TData = TResponse> {
  client: AuctionEnglishQueryClient;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface AuctionEnglishAuctionsByBidderEndTimeQuery<TData> extends AuctionEnglishReactQuery<AuctionsByBidderEndTimeResponse, TData> {
  args: {
    bidder: string;
    queryOptions: QueryOptionsForTokenTimestampOffset;
  };
}
export function useAuctionEnglishAuctionsByBidderEndTimeQuery<TData = AuctionsByBidderEndTimeResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionsByBidderEndTimeQuery<TData>) {
  return useQuery<AuctionsByBidderEndTimeResponse, Error, TData>(["auctionEnglishAuctionsByBidderEndTime", client.contractAddress, JSON.stringify(args)], () => client.auctionsByBidderEndTime({
    bidder: args.bidder,
    queryOptions: args.queryOptions
  }), options);
}
export interface AuctionEnglishAuctionsBySellerEndTimeQuery<TData> extends AuctionEnglishReactQuery<AuctionsBySellerEndTimeResponse, TData> {
  args: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
    seller: string;
  };
}
export function useAuctionEnglishAuctionsBySellerEndTimeQuery<TData = AuctionsBySellerEndTimeResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionsBySellerEndTimeQuery<TData>) {
  return useQuery<AuctionsBySellerEndTimeResponse, Error, TData>(["auctionEnglishAuctionsBySellerEndTime", client.contractAddress, JSON.stringify(args)], () => client.auctionsBySellerEndTime({
    queryOptions: args.queryOptions,
    seller: args.seller
  }), options);
}
export interface AuctionEnglishAuctionsByHighestBidPriceQuery<TData> extends AuctionEnglishReactQuery<AuctionsByHighestBidPriceResponse, TData> {
  args: {
    queryOptions: QueryOptionsForTokenPriceOffset;
  };
}
export function useAuctionEnglishAuctionsByHighestBidPriceQuery<TData = AuctionsByHighestBidPriceResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionsByHighestBidPriceQuery<TData>) {
  return useQuery<AuctionsByHighestBidPriceResponse, Error, TData>(["auctionEnglishAuctionsByHighestBidPrice", client.contractAddress, JSON.stringify(args)], () => client.auctionsByHighestBidPrice({
    queryOptions: args.queryOptions
  }), options);
}
export interface AuctionEnglishAuctionsByEndTimeQuery<TData> extends AuctionEnglishReactQuery<AuctionsByEndTimeResponse, TData> {
  args: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  };
}
export function useAuctionEnglishAuctionsByEndTimeQuery<TData = AuctionsByEndTimeResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionsByEndTimeQuery<TData>) {
  return useQuery<AuctionsByEndTimeResponse, Error, TData>(["auctionEnglishAuctionsByEndTime", client.contractAddress, JSON.stringify(args)], () => client.auctionsByEndTime({
    queryOptions: args.queryOptions
  }), options);
}
export interface AuctionEnglishAuctionsByStartTimeQuery<TData> extends AuctionEnglishReactQuery<AuctionsByStartTimeResponse, TData> {
  args: {
    queryOptions: QueryOptionsForTokenTimestampOffset;
  };
}
export function useAuctionEnglishAuctionsByStartTimeQuery<TData = AuctionsByStartTimeResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionsByStartTimeQuery<TData>) {
  return useQuery<AuctionsByStartTimeResponse, Error, TData>(["auctionEnglishAuctionsByStartTime", client.contractAddress, JSON.stringify(args)], () => client.auctionsByStartTime({
    queryOptions: args.queryOptions
  }), options);
}
export interface AuctionEnglishAuctionQuery<TData> extends AuctionEnglishReactQuery<AuctionResponse, TData> {
  args: {
    tokenId: string;
  };
}
export function useAuctionEnglishAuctionQuery<TData = AuctionResponse>({
  client,
  args,
  options
}: AuctionEnglishAuctionQuery<TData>) {
  return useQuery<AuctionResponse, Error, TData>(["auctionEnglishAuction", client.contractAddress, JSON.stringify(args)], () => client.auction({
    tokenId: args.tokenId
  }), options);
}
export interface AuctionEnglishConfigQuery<TData> extends AuctionEnglishReactQuery<ConfigResponse, TData> {}
export function useAuctionEnglishConfigQuery<TData = ConfigResponse>({
  client,
  options
}: AuctionEnglishConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(["auctionEnglishConfig", client.contractAddress], () => client.config(), options);
}
export interface AuctionEnglishVoidAuctionMutation {
  client: AuctionEnglishClient;
  msg: {
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishVoidAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishVoidAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishVoidAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.voidAuction(msg, fee, memo, funds), options);
}
export interface AuctionEnglishFinalizeAuctionMutation {
  client: AuctionEnglishClient;
  msg: {
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishFinalizeAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishFinalizeAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishFinalizeAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.finalizeAuction(msg, fee, memo, funds), options);
}
export interface AuctionEnglishCloseAuctionMutation {
  client: AuctionEnglishClient;
  msg: {
    acceptHighestBid: boolean;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishCloseAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishCloseAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishCloseAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.closeAuction(msg, fee, memo, funds), options);
}
export interface AuctionEnglishSetAuctionBidMutation {
  client: AuctionEnglishClient;
  msg: {
    price: Coin;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishSetAuctionBidMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishSetAuctionBidMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishSetAuctionBidMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setAuctionBid(msg, fee, memo, funds), options);
}
export interface AuctionEnglishSetAuctionMutation {
  client: AuctionEnglishClient;
  msg: {
    endTime: Timestamp;
    fundsRecipient?: string;
    reservePrice?: Coin;
    startTime: Timestamp;
    startingPrice: Coin;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishSetAuctionMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishSetAuctionMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishSetAuctionMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setAuction(msg, fee, memo, funds), options);
}
export interface AuctionEnglishUpdateConfigMutation {
  client: AuctionEnglishClient;
  msg: {
    bufferDuration?: number;
    closedDuration?: number;
    collectorAddress?: string;
    maxDuration?: number;
    minBidIncrement?: Uint128;
    minDuration?: number;
    minPrice?: Uint128;
    operators?: string[];
    tradingFeeBps?: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useAuctionEnglishUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, AuctionEnglishUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, AuctionEnglishUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}